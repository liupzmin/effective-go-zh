# The blank identifier

*We've mentioned the blank identifier a couple of times now, in the context of for range loops and maps. The blank identifier can be assigned or declared with any value of any type, with the value discarded harmlessly. It's a bit like writing to the Unix /dev/null file: it represents a write-only value to be used as a place-holder where a variable is needed but the actual value is irrelevant. It has uses beyond those we've seen already.*

我们已经在 [For 循环](https://go.dev/doc/effective_go#for) 和 [maps](https://go.dev/doc/effective_go#maps) 中两次提到**空白标识符**了。空白标识符可以用任意类型或任意值来声明和赋值，但其值会被丢弃，然而这并没有什么影响。就好像往 Unix 文件 /dev/null 中写内容一样：它表示一个只写的占位符，用在需要变量但实际值却无关紧要之处。除此之外，空白标识符尚有其它妙用。

## The blank identifier in multiple assignment

*The use of a blank identifier in a for range loop is a special case of a general situation: multiple assignment.*

for 循环中使用空白标识符仅仅是**多重赋值**的一个特例。

*If an assignment requires multiple values on the left side, but one of the values will not be used by the program, a blank identifier on the left-hand-side of the assignment avoids the need to create a dummy variable and makes it clear that the value is to be discarded. For instance, when calling a function that returns a value and an error, but only the error is important, use the blank identifier to discard the irrelevant value.*

如果赋值语句左侧需要多个值，但其中一个将来并不会使用，那么在左侧使用空白标识符可以避免创建虚假变量，并且可清晰地表明变量被丢弃的意图。例如，当调用函数时返回一个值和一个 error，但是仅 error 是重要的，此时即可使用空白标识符来丢弃无关紧要的值。

```go
if _, err := os.Stat(path); os.IsNotExist(err) {
	fmt.Printf("%s does not exist\n", path)
}
```

*Occasionally you'll see code that discards the error value in order to ignore the error; this is terrible practice. Always check error returns; they're provided for a reason.*

有时你会看到为了忽略错误而丢弃 error 的代码；这是个可怕的做法。记住要永远检查错误，事出必有因！

```go
// Bad! This code will crash if path does not exist.
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf("%s is a directory\n", path)
}
```

## Unused imports and variables

*It is an error to import a package or to declare a variable without using it. Unused imports bloat the program and slow compilation, while a variable that is initialized but not used is at least a wasted computation and perhaps indicative of a larger bug. When a program is under active development, however, unused imports and variables often arise and it can be annoying to delete them just to have the compilation proceed, only to have them be needed again later. The blank identifier provides a workaround.*

导入一个包或者声明一个变量却不使用是非法的。未使用的导入会使程序膨胀且拖慢编译速度，而一个未使用的初始化变量至少会浪费算力，或者是一个更大 bug 的迹象。然而，当一个项目处于活跃开发中时，未使用的导入和变量常有发生，而且仅仅为了编译通过将其删除，结果却在不久之后又需要它们，这非常令人讨厌。空白标识符提供了一种变通。

*This half-written program has two unused imports (fmt and io) and an unused variable (fd), so it will not compile, but it would be nice to see if the code so far is correct.*

下面这段未完成的程序有两个未使用的导入（fmt 和 io）和一个未使用的变量（fd），因此它无法编译，但要是能验证一下目前代码的正确性将会非常不错。

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: use fd.
}
```

*To silence complaints about the unused imports, use a blank identifier to refer to a symbol from the imported package. Similarly, assigning the unused variable fd to the blank identifier will silence the unused variable error. This version of the program does compile.*

使用空白标识符引用一个导入包中的符号可以绕过编译器的检查。同样，将一个变量赋值给空白标识符会消除未使用变量的错误。下面这个版本可以编译通过。

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

var _ = fmt.Printf // For debugging; delete when done.
var _ io.Reader    // For debugging; delete when done.

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: use fd.
    _ = fd
}
```

*By convention, the global declarations to silence import errors should come right after the imports and be commented, both to make them easy to find and as a reminder to clean things up later.*

依照惯例，用于消除导入错误的全局声明应该紧跟在导入之后，并加以注释，这样既便于查找，又可以提醒您稍后进行清理。

## Import for side effect

*An unused import like `fmt` or `io` in the previous example should eventually be used or removed: blank assignments identify code as a work in progress. But sometimes it is useful to import a package only for its side effects, without any explicit use. For example, during its `init` function, the `net/http/pprof` package registers HTTP handlers that provide debugging information. It has an exported API, but most clients need only the handler registration and access the data through a web page. To import the package only for its side effects, rename the package to the blank identifier:*

前述案例中未使用的包，比如 `fmt` 或 `io` 最终要么被使用要么被删除：空白赋值表明工作尚在进行中。不过，有时候我们仅仅只是为了副作用而导入一个包，并不会真正的使用它，这是非常有用的。例如，`net/http/pprof` 包在其 **init** 函数中注册了提供调试信息的 `HTTP handlers`。虽然它有一些导出的 API，但大多数客户端只需要 handler 注册后通过网页来访问数据。将导入的包重命名为空白标识符，即可使副作用生效：

```go
import _ "net/http/pprof"
```

*This form of import makes clear that the package is being imported for its side effects, because there is no other possible use of the package: in this file, it doesn't have a name. (If it did, and we didn't use that name, the compiler would reject the program.)*

这种导入方式明确地表明是为了副作用而导入的，因为该包没有其它可能的用途：在此文件中，它没有自己的名字。（如果它有，而我们却没使用它，编译器将会报错。）