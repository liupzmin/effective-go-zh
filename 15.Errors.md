# Errors

*Library routines must often return some sort of error indication to the caller. As mentioned earlier, Go's multivalue return makes it easy to return a detailed error description alongside the normal return value. It is good style to use this feature to provide detailed error information. For example, as we'll see, os.Open doesn't just return a nil pointer on failure, it also returns an error value that describes what went wrong.*

库例程必须总是返回某些类型的错误给调用者。如前所述，Go 拥有多返回值特性，这使得与普通返回值一道返回一个详细的错误描述变得容易。藉由此特性提供错误信息是一种很好的编码风格。如我们即将看到的例子，`os.Open` 函数在其失败时，不止返回一个空指针，同时还伴随一个错误值，用以描述错误发生的原因。

*By convention, errors have type error, a simple built-in interface.*

按照惯例，所有的 errors 都属于 `error` 类型，这是一个简单的内建接口。

```go
type error interface {
    Error() string
}
```

*A library writer is free to implement this interface with a richer model under the covers, making it possible not only to see the error but also to provide some context. As mentioned, alongside the usual `*os.File` return value, os.Open also returns an error value. If the file is opened successfully, the error will be `nil`, but when there is a problem, it will hold an `os.PathError`:*

库作者在实现 error 接口时，可在表象之下自由地实现更加丰富的数据模型，这样接口能提供的信息就不局限于错误描述，还可以附加一些上下文信息。如前所述，除了正常返回 `*os.File` 以外，`os.Open` 还会返回错误值。如果文件打开成功，error 的值将会是 `nil`，否则它将会持有一个 `os.PathError` （`译注：接口的动态类型`）：

```go
// PathError records an error and the operation and
// file path that caused it.
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // The associated file.
    Err error    // Returned by the system call.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
```

*`PathError`'s Error generates a string like this:*

`PathError` 的 Error 方法生成如下字符串：

```go
open /etc/passwx: no such file or directory
```

*Such an error, which includes the problematic file name, the operation, and the operating system error it triggered, is useful even if printed far from the call that caused it; it is much more informative than the plain "no such file or directory".*

这样的 error 不仅包含了问题文件的名称，还包括相关的操作以及触发的系统错误，即使它被打印在远离其调用者的位置，也能为我们提供很多帮助；这样的错误远比未加修饰的 “no such file or directory” 信息量要大。

*When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. For example, in package image, the string representation for a decoding error due to an unknown format is "image: unknown format".*

error 应尽可能标注其出处，比如冠以产生此错误的操作或者包的名称。例如，在 image 包中，因未知格式导致解码错误的信息为 “image: unknown format”。

*Callers that care about the precise error details can use a type switch or a type assertion to look for specific errors and extract details. For PathErrors this might include examining the internal Err field for recoverable failures.*

关注精确错误细节的调用者可使用 type switch 或者 type assertion 来寻找特殊的错误，并从中取得细节。对于 `PathErrors`，可能需要检查内部的 `Err` 字段来为可恢复的失败做另行处理。

```go
for try := 0; try < 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
```

*The second if statement here is another type assertion. If it fails, ok will be false, and e will be nil. If it succeeds, ok will be true, which means the error was of type `*os.PathError`, and then so is e, which we can examine for more information about the error.*

此处第二个 if 语句属于类型断言。如果失败，ok 将是 false，则 e 为 nil。如果成功，ok 将会是 true，这意味着 error 的动态类型是  `*os.PathError`，并且会赋值给 e，也就是说，我们可以从中获取关于错误的更多细节了。

## Panic

*The usual way to report an error to a caller is to return an `error` as an extra return value. The canonical `Read` method is a well-known instance; it returns a byte count and an `error`. But what if the error is unrecoverable? Sometimes the program simply cannot continue.*

向调用者返回错误的寻常做法是返回一个额外的 `error` 值。典型的 `Read` 方法就是个广为人知的例子，它返回一个已读字节数和一个 `error`。但是，如果错误是不可恢复的又将如何呢？有时候因为这些错误，程序根本无法继续运行。

*For this purpose, there is a built-in function `panic` that in effect creates a run-time error that will stop the program (but see the next section). The function takes a single argument of arbitrary type—often a string—to be printed as the program dies. It's also a way to indicate that something impossible has happened, such as exiting an infinite loop.*

为解决此问题，go 提供了一个内建函数 `panic`，事实上它会制造一个运行时错误，进而使程序停止运行（不要恐慌，下一章节有应对之法）。该函数接收一个任意类型的参数（通常都是 string），并在程序死亡之际将其打印出来。这种方式也表明发生了一些不可能的事，例如无限循环退出了。

```go
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i < 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
```

*This is only an example but real library functions should avoid `panic`. If the problem can be masked or worked around, it's always better to let things continue to run rather than taking down the whole program. One possible counterexample is during initialization: if the library truly cannot set itself up, it might be reasonable to panic, so to speak.*

此处仅举例说明，真正的库函数应避免 `panic`。如果问题可以被掩盖或者解决，最好还是让程序继续运行而非粗暴的终结它。初始化过程或许是个例外：如果一个库确实无法设置自身，可以说，`panic` 就是合情合理的。

```go
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
```

