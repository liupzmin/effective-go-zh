# Errors

*Library routines must often return some sort of error indication to the caller. As mentioned earlier, Go's multivalue return makes it easy to return a detailed error description alongside the normal return value. It is good style to use this feature to provide detailed error information. For example, as we'll see, os.Open doesn't just return a nil pointer on failure, it also returns an error value that describes what went wrong.*

库例程必须总是返回某些类型的错误给调用者。如前所述，Go 拥有多返回值特性，这使得与普通返回值一道返回一个详细的错误描述变得容易。藉由此特性提供错误信息是一种很好的编码风格。如我们即将看到的例子，`os.Open` 函数在其失败时，不止返回一个空指针，同时还伴随一个错误值，用以描述错误发生的原因。

*By convention, errors have type error, a simple built-in interface.*

按照惯例，所有的 errors 都属于 `error` 类型，这是一个简单的内建接口。

```go
type error interface {
    Error() string
}
```

*A library writer is free to implement this interface with a richer model under the covers, making it possible not only to see the error but also to provide some context. As mentioned, alongside the usual `*os.File` return value, os.Open also returns an error value. If the file is opened successfully, the error will be `nil`, but when there is a problem, it will hold an `os.PathError`:*

库作者在实现 error 接口时，可在表象之下自由地实现更加丰富的数据模型，这样接口能提供的信息就不局限于错误描述，还可以附加一些上下文信息。如前所述，除了正常返回 `*os.File` 以外，`os.Open` 还会返回错误值。如果文件打开成功，error 的值将会是 `nil`，否则它将会持有一个 `os.PathError` （`译注：接口的动态类型`）：

```go
// PathError records an error and the operation and
// file path that caused it.
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // The associated file.
    Err error    // Returned by the system call.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
```

*`PathError`'s Error generates a string like this:*

`PathError` 的 Error 方法生成如下字符串：

```go
open /etc/passwx: no such file or directory
```

*Such an error, which includes the problematic file name, the operation, and the operating system error it triggered, is useful even if printed far from the call that caused it; it is much more informative than the plain "no such file or directory".*

这样的 error 不仅包含了问题文件的名称，还包括相关的操作以及触发的系统错误，即使它被打印在远离其调用者的位置，也能为我们提供很多帮助；这样的错误远比未加修饰的 “no such file or directory” 信息量要大。

*When feasible, error strings should identify their origin, such as by having a prefix naming the operation or package that generated the error. For example, in package image, the string representation for a decoding error due to an unknown format is "image: unknown format".*

error 应尽可能标注其出处，比如冠以产生此错误的操作或者包的名称。例如，在 image 包中，因未知格式导致解码错误的信息为 “image: unknown format”。

*Callers that care about the precise error details can use a type switch or a type assertion to look for specific errors and extract details. For PathErrors this might include examining the internal Err field for recoverable failures.*

关注精确错误细节的调用者可使用 type switch 或者 type assertion 来寻找特殊的错误，并从中取得细节。对于 `PathErrors`，可能需要检查内部的 `Err` 字段来为可恢复的失败做另行处理。

```go
for try := 0; try < 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
```

*The second if statement here is another type assertion. If it fails, ok will be false, and e will be nil. If it succeeds, ok will be true, which means the error was of type `*os.PathError`, and then so is e, which we can examine for more information about the error.*

此处第二个 if 语句属于类型断言。如果失败，ok 将是 false，则 e 为 nil。如果成功，ok 将会是 true，这意味着 error 的动态类型是  `*os.PathError`，并且会赋值给 e，也就是说，我们可以从中获取关于错误的更多细节了。