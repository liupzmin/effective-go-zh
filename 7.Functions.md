# Functions

## Multiple return values

*One of Go's unusual features is that functions and methods can return multiple values. This form can be used to improve on a couple of clumsy idioms in C programs: in-band error returns such as -1 for EOF and modifying an argument passed by address.*

**函数和方法具有多个返回值**是 Go 的特性之一，此特性可在很大程度上矫正 C 语言一些笨拙的编码风格：带内错误返回值，例如用 -1 表示 EOF ，还有通过传址修改参数。

> 译注：带内（in-band）和带外（out-of-band）是通讯领域的概念，《UNIX网络编程》卷一第 24 章有关于带外数据的描述，带内数据资料甚少，有熟悉的朋友可以提供一下，另 [Error Handling](https://segmentfault.com/a/1190000022578862) 一文高屋建瓴，立意颇深，有兴趣的读者可以一观。

*In C, a write error is signaled by a negative count with the error code secreted away in a volatile location. In Go, Write can return a count and an error: “Yes, you wrote some bytes but not all of them because you filled the device”. The signature of the Write method on files from package os is:*

在 C 中，通过一个负的写入数量来表示 write 发生错误 ，而且其错误码隐藏在一个很不稳定的位置（译注：这里指 errno 是一个全局变量，errno 的值只有在一个库函数调用发生错误时才会被设置，当库函数调用成功运行时，errno 的值不会被修改，当然也不会主动被置为 0）。在 Go 中，`Write ` 可以同时返回写入数量和一个 error：“没错，因为磁盘爆满，并非所有的字节都被成功写入”。`os` 包中关于`file`的写入函数签名为：

```go
func (file *File) Write(b []byte) (n int, err error)
```

*and as the documentation says, it returns the number of bytes written and a non-nil error when n != len(b). This is a common style; see the section on error handling for more examples.*

正如文档所示，当 **n != len(b)** 时，它返回已写入的字节数和一个非 nil 的 error。这是一种常见风格，更多示例见错误处理章节。

*A similar approach obviates the need to pass a pointer to a return value to simulate a reference parameter. Here's a simple-minded function to grab a number from a position in a byte slice, returning the number and the next position.*

这种多返回值的方式，不再需要传递一个指针，不再需要把返回值伪装成一个引用参数。这里有一个用于从字节切片特定位置提取数字并返回该数字和下一个位置的函数，它的实现非常朴实无华：

```go
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
```

*You could use it to scan the numbers in an input slice b like this:*

你可以使用它从切片 `b` 扫描数字，就像这样：

```go
for i := 0; i < len(b); {
    x, i = nextInt(b, i)
    fmt.Println(x)
}
```

## Named result parameters

*The return or result "parameters" of a Go function can be given names and used as regular variables, just like the incoming parameters. When named, they are initialized to the zero values for their types when the function begins; if the function executes a return statement with no arguments, the current values of the result parameters are used as the returned values.*

Go 函数的返回参数可以被命名，且可以像入参一样当做常规变量来使用。一旦被命名，它们将在函数开始时被初始化为相应类型的零值；如果此函数的 return 语句没有施加参数，则被命名的当前结果参数值将被当作返回值返回。

*The names are not mandatory but they can make code shorter and clearer: they're documentation. If we name the results of nextInt it becomes obvious which returned int is which.*

对返回参数命名并非强制性的，但这样做可以使代码更加简短：因为他们是自解释的。假使我们对返回值 nextInt 进行命名，那么返回的 int 是哪一个将一目了然。

```go
func nextInt(b []byte, pos int) (value, nextPos int) {
```

*Because named results are initialized and tied to an unadorned return, they can simplify as well as clarify. Here's a version of io.ReadFull that uses them well:*

因为命名的结果值会被初始化，而且在函数中使用 return 不再需要追加参数，如此则非常简洁明白。这里有一个 io.ReadFull 函数的使用范例：

```go
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
```





