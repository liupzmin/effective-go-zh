# Control structures

*The control structures of Go are related to those of C but differ in important ways. There is no do or while loop, only a slightly generalized for; switch is more flexible; if and switch accept an optional initialization statement like that of for; break and continue statements take an optional label to identify what to break or continue; and there are new control structures including a type switch and a multiway communications multiplexer, select. The syntax is also slightly different: there are no parentheses and the bodies must always be brace-delimited.*

Go 中的控制结构和 C 有一定的相关性，但在一些重要方面有所不同。Go 没有 `do` 或者 `while` 循环，只靠一个`for`走天下；`switch`则更加灵活；类似于`for`，`if` 和 `switch`都接受一个可选的初始化语句；`break` 和 `continue` 可以跟一个可选标签来表示跳出和继续的对象；还有，Go 拥有新的控制结构，包扩 `type switch`和多路通信复用 `select` 。语法也有些许变化：没有圆括号、控制体必须要置于大括号之内。

## If

*In Go a simple if looks like this:*

下面是 Go 中的一个简单的 `if` ：

```go
if x > 0 {
    return y
}
```

*Mandatory braces encourage writing simple if statements on multiple lines. It's good style to do so anyway, especially when the body contains a control statement such as a return or break*

强制使用大括号，以此鼓励编写**多行简单的** if 语句。总之，这是一种良好的代码风格，尤其是 body 中包含诸如 return、break等控制结构的时候。

*Since if and switch accept an initialization statement, it's common to see one used to set up a local variable.*

正是因为 `if`和`switch`都能使用初始化语句，所以经常会看到如下设置本地变量的用法。

```go
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
```

*In the Go libraries, you'll find that when an if statement doesn't flow into the next statement—that is, the body ends in break, continue, goto, or return—the unnecessary else is omitted.*

在 Go 的标准库中，你会发现，当一个 if 语句成为终结者的时候—意为：body 以 break，continue，goto，或return 结束，此时会省略已经没必要的`else`。

```go
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
```

*This is an example of a common situation where code must guard against a sequence of error conditions. The code reads well if the successful flow of control runs down the page, eliminating error cases as they arise. Since error cases tend to end in return statements, the resulting code needs no else statements.*

下面的示例涉及到一个非常普遍的情况，**代码必须防范一连串的错误情况**。如果语句成功则向下执行，遇到错误则处理错误，代码就具有高可读性。由于错误情况的处理往往以 return 语句结束，所以代码不需要`else` 语句。

```go
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
```

