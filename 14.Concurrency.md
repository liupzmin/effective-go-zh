# Concurrency

## Share by communicating

*Concurrent programming is a large topic and there is space only for some Go-specific highlights here.*

并发编程所涉过于庞大，此处仅就 Go 的特殊之处论之。

*Concurrent programming in many environments is made difficult by the subtleties required to implement correct access to shared variables. Go encourages a different approach in which shared values are passed around on channels and, in fact, never actively shared by separate threads of execution. Only one goroutine has access to the value at any given time. Data races cannot occur, by design. To encourage this way of thinking we have reduced it to a slogan:*

很多环境下的并发编程因一些微妙之处变得很困难，问题在于你需要实现对共享变量的正确访问。Go 鼓励一种不同的方式：将需要共享的值通过 channel 来传递。事实上，不要一味地在不同的执行流之间共享数据。在任意给定的时刻有且仅有一个 goroutine 可以访问该值。Go channel 在设计上就消除了这种数据竞争。为鼓励这种思维方式，我们将其归纳为一条 slogan：

> Do not communicate by sharing memory; instead, share memory by communicating.
>
> 不要通过共享内存来通信，而是通过通信来共享内存。

*This approach can be taken too far. Reference counts may be best done by putting a mutex around an integer variable, for instance. But as a high-level approach, using channels to control access makes it easier to write clear, correct programs.*

有时这种方式可能会显得有些过头。比如对于计数器最好的的访问方式是为整型变量添加一个 mutex。然而，在高层次上将，使用 channel 来控制数据的访问会使编写清晰，正确的程序变得简单。

*One way to think about this model is to consider a typical single-threaded program running on one CPU. It has no need for synchronization primitives. Now run another such instance; it too needs no synchronization. Now let those two communicate; if the communication is the synchronizer, there's still no need for other synchronization. Unix pipelines, for example, fit this model perfectly. Although Go's approach to concurrency originates in Hoare's Communicating Sequential Processes (CSP), it can also be seen as a type-safe generalization of Unix pipes.*

为便于理解此并发模型，考虑一个跑在单核 CPU 上典型的单线程程序。它是不需要同步源语的。现在再运行一个此程序的实例，也是不需要同步的。现在让它们两个通信，如果通信本身就是一个同步装置，那么仍然不需要其它形式的同步。例如，Unix 管道就与此模型完美契合。尽管 Go 的并发模型源自于 Hoare 的 CSP 模型，但它依然可以看做是类型安全的 Unix 管道的泛化。

## Goroutines

*They're called **goroutines** because the existing terms—threads, coroutines, processes, and so on—convey inaccurate connotations. A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required.*

Go 的并发单位被称作 **goroutines**，是因为现存的术语——线程，协程，进程等都无法传达其隐含的意义。goroutine 的模型很简单：它是一个与其它的 groutine 并发运行于同一地址空间的函数。groutine 是轻量的，成本略高于堆栈空间的分配。而且 goroutine 的初始堆栈很小，因此非常廉价，并能从 heap 上按需增长。

*Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run. Their design hides many of the complexities of thread creation and management.*

Goroutine 在多个操作系统线程上多路复用，因此如果一个被阻塞（例如 I/O等待），则其它的 goroutine 可继续调度到其它操作系统上运行。Goroutine 的设计隐藏了很多线程创建和管理的复杂性。

*Prefix a function or method call with the `go` keyword to run the call in a new goroutine. When the call completes, the goroutine exits, silently. (The effect is similar to the Unix shell's `&` notation for running a command in the background.)*

在函数或者方法前使用 `go` 关键字即可开启一个新的 goroutine。当调用完成，goroutine 就会默默退出。（其效果类似于 Unlix shell 的 `&` 符号，它的作用是让一个命令在后台运行。）

```go
go list.Sort()  // run list.Sort concurrently; don't wait for it.
```

*A function literal can be handy in a goroutine invocation.*

函数的字面值可以出现在 goroutine 的调用中。

```go
func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Note the parentheses - must call the function.
}
```

*In Go, function literals are closures: the implementation makes sure the variables referred to by the function survive as long as they are active.*

在 Go 中，函数字面值是闭包的：这确保了被函数引用的变量在其活跃期间一直存活（意为有足够的生存期）。

*These examples aren't too practical because the functions have no way of signaling completion. For that, we need channels.*

这些例子不太实用，因为函数没有办法发出完成的信号。为此，我们需要 channel。